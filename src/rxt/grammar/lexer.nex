
<                     { if !state.started { state.started = true; if retVal(emitObj("CTX", state.rootEnv)) != 0 { return } } }
/[#].*\n/             { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); /* eat up comments */ }
/,[ \n\t]*/           { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); if retVal(emitStr("PNC", token()[:1])) != 0 { return } }
/[\n][ \t\n]*/        { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); indent( token() ); if retVal(emitInd()) != 0 { return } }
/[ \t]+/              { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); /* eat up whitespace */ }
/WITH OPTIONS|DATASET|FOR SERVICE|FOR STACK|DEFINE AUTH|AS|SET|TO|GET|POST|FROM|EXTRACT USING|METRIC|NAME|TYPE|GAUGE|COUNTER|HISTOGRAM|SUMMARY|DESCRIPTION|LABELS/ { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); if retVal(emitStr("KEY", token())) != 0 { return } }
/"[^"]*"/             { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); if retVal(emitStr("STR", token())) != 0 { return } }
/'[^']*'/             { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); if retVal(emitStr("STR", token())) != 0 { return } }
/[a-z_][a-z0-9_]*/    { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); if retVal(emitStr("VAR", token())) != 0 { return } }
/./                   { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); emitErr("Unexpected token " + token()) }
>                     { fmt.Println("LEXER", yylex.Line() + 1, yylex.Text()); /* nothing to do at end of file */ }
//
package grammar
import "os"
import "fmt"

func (lex *Lexer) emitIndentTokens(state *lexerState) int {
  for state.nextIndent < len(state.pendIndent) {
    tok := &state.pendIndent[state.nextIndent]
    state.nextIndent++
    if tokId := state.handler.EmitInt(tok.tokTyp, tok.tokVal); tokId != 0 {
      return tokId
    }
  }
  state.pendIndent = nil
  state.nextIndent = 0
  return 0
}

func (lex *Lexer) Lex(state *lexerState) int {
  // Clear return value
  // Emit any pending indentation tokens
  token := lex.Text
  emitStr := state.handler.EmitStr
  emitObj := state.handler.EmitObj
  emitErr := state.handler.Error
  emitInd := func() int { return lex.emitIndentTokens(state) }
  indent := state.indent
  retVal := func(value int) int { state.retVal = value; return value }
  if tokId := emitInd(); tokId != 0 {
    return tokId
  }
  NN_FUN(lex)
  return state.retVal
}

func (lex Lexer) Error(e string) {
	panic(e)
}

func LexTheRxt(handler TokenHandler, rootEnv interface{}) {
  lex := NewLexer(os.Stdin)
  tokenId := 1
  state := lexerState{
    handler: handler,
  }
  for tokenId > 0 {
    tokenId = lex.Lex(&state)
  }
}
